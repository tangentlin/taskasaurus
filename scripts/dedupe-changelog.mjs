#!/usr/bin/env node
/**
 * Deduplicates changelog entries generated by changelogen.
 *
 * When using GitHub's squash-and-merge, both the original commit and the merge
 * commit may appear in the changelog with the same description. This script
 * removes duplicates, preferring entries with PR references over commit hashes.
 *
 * Usage: node scripts/dedupe-changelog.mjs [changelog-path]
 */

import { readFileSync, writeFileSync } from "node:fs";

const changelogPath = process.argv[2] || "CHANGELOG.md";

const content = readFileSync(changelogPath, "utf8");
const lines = content.split("\n");

const result = [];
let inSection = false;
let sectionLines = [];
let currentSectionHeader = null;

// Regex to match changelog entry lines like:
// - Description text ([#123](url)) or ([abc1234](url))
const entryRegex = /^- (.+?)(?:\s*\((\[#\d+\]|\[[a-f0-9]+\])\([^)]+\)\))?$/;
const prRefRegex = /\[#\d+\]/;
const hashRefRegex = /\[[a-f0-9]{7,}\]/;

// Regex to match contributor lines like:
// - Name <email> or - Name
const contributorRegex = /^- .+$/;

function processSection(header, lines) {
  if (!header) return lines;

  // Check if this is a contributors section
  const isContributorSection = /contributors/i.test(header);

  if (isContributorSection) {
    // Dedupe contributors by name (case-insensitive, ignoring email variations)
    const seen = new Map();
    const deduped = [];

    for (const line of lines) {
      if (!line.startsWith("- ")) {
        deduped.push(line);
        continue;
      }

      // Extract contributor name (before any email or parenthetical)
      const nameMatch = line.match(/^- ([^<(]+)/);
      if (nameMatch) {
        const name = nameMatch[1].trim().toLowerCase();
        if (!seen.has(name)) {
          seen.set(name, line);
          deduped.push(line);
        }
      } else {
        deduped.push(line);
      }
    }

    return deduped;
  }

  // For changelog sections, dedupe by description text
  // Group entries by their description (text before the reference)
  const entries = new Map();
  const otherLines = [];

  for (const line of lines) {
    if (!line.startsWith("- ")) {
      otherLines.push(line);
      continue;
    }

    // Extract the description (everything before the last parenthetical reference)
    // Handle: "- Description ([#123](url))" or "- Description ([hash](url))"
    const descMatch = line.match(/^- (.+?)\s*\(\[/);
    const description = descMatch ? descMatch[1].trim() : line.slice(2).trim();

    const hasPrRef = prRefRegex.test(line);
    const hasHashRef = hashRefRegex.test(line);

    if (entries.has(description)) {
      const existing = entries.get(description);
      // Prefer PR reference over hash reference
      if (hasPrRef && !existing.hasPrRef) {
        entries.set(description, { line, hasPrRef, hasHashRef });
      }
      // Otherwise keep the existing entry
    } else {
      entries.set(description, { line, hasPrRef, hasHashRef });
    }
  }

  // Reconstruct the section preserving order of first occurrence
  const deduped = [];
  const addedDescriptions = new Set();

  for (const line of lines) {
    if (!line.startsWith("- ")) {
      deduped.push(line);
      continue;
    }

    const descMatch = line.match(/^- (.+?)\s*\(\[/);
    const description = descMatch ? descMatch[1].trim() : line.slice(2).trim();

    if (!addedDescriptions.has(description)) {
      addedDescriptions.add(description);
      const entry = entries.get(description);
      if (entry) {
        deduped.push(entry.line);
      }
    }
  }

  return deduped;
}

// Process the changelog line by line
for (let i = 0; i < lines.length; i++) {
  const line = lines[i];

  // Check for section headers (### Something)
  if (line.startsWith("### ")) {
    // Process previous section if any
    if (currentSectionHeader !== null) {
      result.push(currentSectionHeader);
      result.push(...processSection(currentSectionHeader, sectionLines));
    }

    currentSectionHeader = line;
    sectionLines = [];
    inSection = true;
  } else if (line.startsWith("## ") && inSection) {
    // New version section - flush current section
    if (currentSectionHeader !== null) {
      result.push(currentSectionHeader);
      result.push(...processSection(currentSectionHeader, sectionLines));
    }

    currentSectionHeader = null;
    sectionLines = [];
    inSection = false;
    result.push(line);
  } else if (inSection) {
    sectionLines.push(line);
  } else {
    result.push(line);
  }
}

// Don't forget the last section
if (currentSectionHeader !== null) {
  result.push(currentSectionHeader);
  result.push(...processSection(currentSectionHeader, sectionLines));
}

writeFileSync(changelogPath, result.join("\n"));
console.log(`Deduplicated ${changelogPath}`);
